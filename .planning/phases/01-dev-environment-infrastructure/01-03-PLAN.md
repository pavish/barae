---
phase: 01-dev-environment-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - caddy/Caddyfile.dev
  - caddy/Caddyfile.prod
  - Dockerfile.backend
  - Dockerfile.proxy
  - compose.dev.yml
  - compose.prod.yml
  - compose.test.yml
  - .env.example
  - .gitignore
  - backend/Dockerfile
  - backend/.dockerignore
  - frontend/Dockerfile
  - frontend/.dockerignore
  - frontend/nginx.conf
autonomous: true

must_haves:
  truths:
    - "Caddy dev config proxies /api/* to backend (stripping /api/ prefix) and everything else to Vite frontend, on port 8100 HTTP only"
    - "Caddy prod config serves static files from /srv with SPA fallback, proxies /api/* to backend, with auto-HTTPS and security headers"
    - "Dockerfiles are at project root (Dockerfile.backend and Dockerfile.proxy), not inside subdirectories"
    - "Dev compose starts db, mailpit, backend, frontend (Vite), and proxy (Caddy) -- accessible at localhost:8100"
    - "Prod compose starts db, backend, and proxy (Caddy serving built static files) -- no separate frontend container"
    - "Test compose uses ephemeral DB (tmpfs), backend only, no proxy needed"
    - "Container names use barae- prefix (barae-dev-*, barae-*)"
    - "Old nginx.conf and subdirectory Dockerfiles are deleted"
  artifacts:
    - path: "caddy/Caddyfile.dev"
      provides: "Caddy dev config - HTTP proxy to Vite + backend"
      contains: "handle_path /api/*"
    - path: "caddy/Caddyfile.prod"
      provides: "Caddy prod config - HTTPS, static files, backend proxy"
      contains: "try_files"
    - path: "Dockerfile.backend"
      provides: "Backend multi-stage Dockerfile at root"
      contains: "FROM node:22-alpine"
    - path: "Dockerfile.proxy"
      provides: "Proxy multi-stage Dockerfile at root (dev: Caddy-only, prod: Caddy+static)"
      contains: "FROM caddy:2-alpine"
    - path: "compose.dev.yml"
      provides: "Dev stack with 5 services: db, mailpit, backend, frontend, proxy"
      contains: "barae-dev-proxy"
  key_links:
    - from: "compose.dev.yml"
      to: "Dockerfile.backend"
      via: "build.dockerfile"
      pattern: "Dockerfile\\.backend"
    - from: "compose.dev.yml"
      to: "Dockerfile.proxy"
      via: "build.dockerfile"
      pattern: "Dockerfile\\.proxy"
    - from: "caddy/Caddyfile.dev"
      to: "compose.dev.yml backend service"
      via: "reverse_proxy backend:3000"
      pattern: "reverse_proxy backend:3000"
    - from: "caddy/Caddyfile.dev"
      to: "compose.dev.yml frontend service"
      via: "reverse_proxy frontend:5173"
      pattern: "reverse_proxy frontend:5173"
---

<objective>
Build the Docker and Caddy infrastructure: create Caddy configurations for dev and prod, create root-level multi-stage Dockerfiles for backend and proxy, rewrite all three Docker Compose files for the new architecture, update .env.example, and clean up old files (nginx.conf, subdirectory Dockerfiles).

Purpose: Establish the containerized development and production environments that make everything accessible at localhost:8100 in dev and support auto-HTTPS in production.
Output: Complete Docker/Caddy infrastructure with dev, prod, and test compose files all configured correctly.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STANDARDS.md
@.planning/phases/01-dev-environment-infrastructure/01-CONTEXT.md
@.planning/phases/01-dev-environment-infrastructure/01-RESEARCH.md
@.planning/phases/01-dev-environment-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-dev-environment-infrastructure/01-02-SUMMARY.md
@compose.dev.yml
@compose.prod.yml
@compose.test.yml
@.env.example
@backend/Dockerfile
@frontend/Dockerfile
@frontend/nginx.conf
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Caddy configs + Proxy Dockerfile</name>
  <files>caddy/Caddyfile.dev, caddy/Caddyfile.prod, Dockerfile.proxy</files>
  <action>
  1. Create `caddy/` directory at project root.

  2. Create `caddy/Caddyfile.dev`:
     ```caddyfile
     {
     	auto_https off
     }

     :8100 {
     	# API routes: strip /api/ prefix, proxy to backend
     	handle_path /api/* {
     		reverse_proxy backend:3000
     	}

     	# Everything else: proxy to Vite dev server
     	reverse_proxy frontend:5173
     }
     ```
     Key points:
     - `auto_https off` prevents HTTPS in dev
     - `:8100` explicit port binding
     - `handle_path` strips `/api/` before proxying -- Fastify sees clean routes like `/v1/auth/login`
     - Default route goes to Vite dev server (includes WebSocket for HMR -- Caddy handles upgrade transparently)

  3. Create `caddy/Caddyfile.prod`:
     ```caddyfile
     {$DOMAIN} {
     	encode gzip

     	# Security headers
     	header {
     		Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
     		X-Content-Type-Options "nosniff"
     		X-Frame-Options "DENY"
     		Referrer-Policy "strict-origin-when-cross-origin"
     		Permissions-Policy "camera=(), microphone=(), geolocation=()"
     		-Server
     	}

     	# API routes: strip /api/ prefix, proxy to backend
     	handle_path /api/* {
     		reverse_proxy backend:3000
     	}

     	# Static frontend files with SPA fallback
     	handle {
     		root * /srv
     		try_files {path} /index.html
     		file_server
     	}
     }
     ```
     Key points:
     - `{$DOMAIN}` is a Caddy environment variable placeholder -- set DOMAIN in .env for prod
     - Caddy auto-HTTPS handles Let's Encrypt certificates automatically
     - Security headers at edge (HSTS, X-Content-Type-Options, X-Frame-Options, Referrer-Policy, Permissions-Policy, remove Server header)
     - `encode gzip` for compression
     - `try_files` with `/index.html` fallback for SPA routing

  4. Create `Dockerfile.proxy` at project root:
     ```dockerfile
     # ============================================
     # Dev stage: Caddy as reverse proxy only
     # ============================================
     FROM caddy:2-alpine AS dev

     COPY caddy/Caddyfile.dev /etc/caddy/Caddyfile

     EXPOSE 8100

     # ============================================
     # Dev frontend stage: Vite dev server
     # ============================================
     FROM node:22-alpine AS dev-frontend

     WORKDIR /app

     RUN apk add --no-cache libc6-compat

     COPY frontend/package.json frontend/package-lock.json* ./
     RUN npm ci

     COPY frontend/ .

     EXPOSE 5173

     CMD ["npm", "run", "dev"]

     # ============================================
     # Build stage: Build frontend assets
     # ============================================
     FROM node:22-alpine AS build

     WORKDIR /app

     COPY frontend/package.json frontend/package-lock.json* ./
     RUN npm ci

     COPY frontend/ .
     RUN npm run build

     # ============================================
     # Prod stage: Caddy serving static files
     # ============================================
     FROM caddy:2-alpine AS prod

     COPY caddy/Caddyfile.prod /etc/caddy/Caddyfile
     COPY --from=build /app/dist /srv

     EXPOSE 80 443
     ```
     Key points:
     - `dev` stage: Caddy-only container, just the reverse proxy config
     - `dev-frontend` stage: Node container running Vite dev server. This is a SEPARATE container in dev (one-process-per-container). The compose file targets this stage for the frontend service.
     - `build` stage: Builds frontend assets (intermediate)
     - `prod` stage: Caddy with built static files baked in
     - Build context is project root (.), so COPY uses `frontend/` prefix
  </action>
  <verify>
  - `cat caddy/Caddyfile.dev` -- shows handle_path /api/*, reverse_proxy frontend:5173, auto_https off, :8100
  - `cat caddy/Caddyfile.prod` -- shows {$DOMAIN}, security headers, handle_path /api/*, try_files, file_server
  - `cat Dockerfile.proxy` -- shows 4 stages: dev (caddy), dev-frontend (node+vite), build (node), prod (caddy+static)
  </verify>
  <done>Caddy dev/prod configs created. Proxy Dockerfile at root with multi-stage for dev (Caddy-only), dev-frontend (Vite), and prod (Caddy+static).</done>
</task>

<task type="auto">
  <name>Task 2: Backend Dockerfile at root + all compose files + env + cleanup</name>
  <files>Dockerfile.backend, compose.dev.yml, compose.prod.yml, compose.test.yml, .env.example, .gitignore, backend/Dockerfile, backend/.dockerignore, frontend/Dockerfile, frontend/.dockerignore, frontend/nginx.conf</files>
  <action>
  1. Create `Dockerfile.backend` at project root (NOT in backend/ subdirectory):
     ```dockerfile
     # ============================================
     # Base stage
     # ============================================
     FROM node:22-alpine AS base
     WORKDIR /app
     RUN apk add --no-cache libc6-compat

     # ============================================
     # Dependencies
     # ============================================
     FROM base AS deps
     COPY backend/package.json backend/package-lock.json* ./
     RUN npm ci

     # ============================================
     # Development
     # ============================================
     FROM base AS dev
     WORKDIR /app
     COPY --from=deps /app/node_modules ./node_modules
     COPY backend/package.json ./
     EXPOSE 3000
     CMD ["npm", "run", "dev"]

     # ============================================
     # Build
     # ============================================
     FROM base AS build
     WORKDIR /app
     COPY --from=deps /app/node_modules ./node_modules
     COPY backend/ .
     RUN npm run build
     RUN npm prune --production

     # ============================================
     # Production
     # ============================================
     FROM node:22-alpine AS prod
     WORKDIR /app
     RUN addgroup --system --gid 1001 nodejs && \
         adduser --system --uid 1001 barae
     COPY --from=build --chown=barae:nodejs /app/dist ./dist
     COPY --from=build --chown=barae:nodejs /app/node_modules ./node_modules
     COPY --from=build --chown=barae:nodejs /app/package.json ./
     COPY --from=build --chown=barae:nodejs /app/migrations ./migrations
     COPY --from=build --chown=barae:nodejs /app/scripts ./scripts
     USER barae
     EXPOSE 3000
     ENV NODE_ENV=production
     HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
       CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1
     CMD ["node", "dist/index.js"]
     ```
     Key differences from old backend/Dockerfile:
     - At project root -- COPY uses `backend/` prefix for source files
     - Copies `migrations/` and `scripts/` to prod image (for running migration script)
     - Scripts directory included so `npx tsx scripts/migrate.ts` can run in prod container

  2. Rewrite `compose.dev.yml`:
     ```yaml
     # Development - docker compose -f compose.dev.yml up
     services:
       db:
         container_name: barae-dev-db
         image: postgres:17-alpine
         restart: unless-stopped
         environment:
           POSTGRES_USER: ${POSTGRES_USER}
           POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
           POSTGRES_DB: ${POSTGRES_DB}
         volumes:
           - dev-pg-data:/var/lib/postgresql/data
         ports:
           - "${POSTGRES_PORT:-5432}:5432"
         healthcheck:
           test: ["CMD-SHELL", "pg_isready -d ${POSTGRES_DB} -U ${POSTGRES_USER}"]
           interval: 5s
           timeout: 3s
           retries: 30

       mailpit:
         container_name: barae-dev-mailpit
         image: axllent/mailpit:latest
         restart: unless-stopped
         ports:
           - "8025:8025"
           - "1025:1025"
         environment:
           MP_SMTP_AUTH_ACCEPT_ANY: 1
           MP_SMTP_AUTH_ALLOW_INSECURE: 1

       backend:
         container_name: barae-dev-backend
         build:
           context: .
           dockerfile: Dockerfile.backend
           target: dev
         depends_on:
           db:
             condition: service_healthy
           mailpit:
             condition: service_started
         env_file: .env
         environment:
           POSTGRES_HOST: db
           POSTGRES_PORT: 5432
           SMTP_HOST: ${SMTP_HOST:-mailpit}
           SMTP_PORT: ${SMTP_PORT:-1025}
           SMTP_USER: ${SMTP_USER:-}
           SMTP_PASSWORD: ${SMTP_PASSWORD:-}
           SMTP_SECURE: ${SMTP_SECURE:-false}
           EMAIL_FROM: ${EMAIL_FROM:-Barae <noreply@barae.local>}
         volumes:
           - ./backend:/app
           - /app/node_modules
         healthcheck:
           test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
           interval: 10s
           timeout: 3s
           retries: 30
           start_period: 10s

       frontend:
         container_name: barae-dev-frontend
         build:
           context: .
           dockerfile: Dockerfile.proxy
           target: dev-frontend
         volumes:
           - ./frontend:/app
           - /app/node_modules

       proxy:
         container_name: barae-dev-proxy
         build:
           context: .
           dockerfile: Dockerfile.proxy
           target: dev
         depends_on:
           backend:
             condition: service_healthy
           frontend:
             condition: service_started
         ports:
           - "8100:8100"
         volumes:
           - ./caddy/Caddyfile.dev:/etc/caddy/Caddyfile

     volumes:
       dev-pg-data:
     ```
     Key changes from existing:
     - Build context is `.` (project root) for both backend and proxy
     - backend uses `Dockerfile.backend` instead of `./backend` context
     - `frontend` service targets `dev-frontend` stage of `Dockerfile.proxy` (runs Vite)
     - `frontend` has NO ports exposed (only accessed through proxy)
     - `frontend` has NO env_file (frontend never uses env vars)
     - New `proxy` service (Caddy) depends on backend + frontend, exposes port 8100
     - Backend NO LONGER exposes ports directly (accessed through Caddy proxy)
     - Caddy Caddyfile.dev is bind-mounted for live config changes

  3. Rewrite `compose.prod.yml`:
     ```yaml
     # Production - docker compose -f compose.prod.yml up -d
     services:
       db:
         container_name: barae-db
         image: postgres:17-alpine
         restart: always
         environment:
           POSTGRES_USER: ${POSTGRES_USER}
           POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
           POSTGRES_DB: ${POSTGRES_DB}
         volumes:
           - pg-data:/var/lib/postgresql/data
         healthcheck:
           test: ["CMD-SHELL", "pg_isready -d ${POSTGRES_DB} -U ${POSTGRES_USER}"]
           interval: 10s
           timeout: 5s
           retries: 5

       backend:
         container_name: barae-backend
         build:
           context: .
           dockerfile: Dockerfile.backend
           target: prod
         restart: always
         depends_on:
           db:
             condition: service_healthy
         env_file: .env
         environment:
           NODE_ENV: production
           POSTGRES_HOST: db
           POSTGRES_PORT: 5432
         expose:
           - "3000"
         healthcheck:
           test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
           interval: 30s
           timeout: 3s
           retries: 3
           start_period: 10s

       proxy:
         container_name: barae-proxy
         build:
           context: .
           dockerfile: Dockerfile.proxy
           target: prod
         restart: always
         depends_on:
           backend:
             condition: service_healthy
         environment:
           DOMAIN: ${DOMAIN:-localhost}
         ports:
           - "80:80"
           - "443:443"
         volumes:
           - caddy-data:/data
           - caddy-config:/config

     volumes:
       pg-data:
       caddy-data:
       caddy-config:
     ```
     Key changes from existing:
     - `frontend` service replaced by `proxy` service (Caddy serves static files from prod stage)
     - No separate frontend container in prod (static files baked into Caddy image)
     - Caddy volumes for cert persistence (caddy-data, caddy-config)
     - DOMAIN env var for Caddy site address
     - Ports 80 and 443 (Caddy handles HTTP->HTTPS redirect)
     - Removed MIGRATE_ON_START (migrations run separately before deployment)

  4. Rewrite `compose.test.yml`:
     ```yaml
     # Testing - docker compose -f compose.test.yml up --build --abort-on-container-exit
     services:
       db:
         container_name: barae-test-db
         image: postgres:17-alpine
         environment:
           POSTGRES_USER: barae
           POSTGRES_PASSWORD: testpassword
           POSTGRES_DB: barae_test
         tmpfs:
           - /var/lib/postgresql/data
         healthcheck:
           test: ["CMD-SHELL", "pg_isready -d barae_test -U barae"]
           interval: 2s
           timeout: 2s
           retries: 10

       mailpit:
         container_name: barae-test-mailpit
         image: axllent/mailpit:latest
         environment:
           MP_SMTP_AUTH_ACCEPT_ANY: 1
           MP_SMTP_AUTH_ALLOW_INSECURE: 1

       backend:
         container_name: barae-test-backend
         build:
           context: .
           dockerfile: Dockerfile.backend
           target: prod
         depends_on:
           db:
             condition: service_healthy
           mailpit:
             condition: service_started
         environment:
           POSTGRES_HOST: db
           POSTGRES_PORT: 5432
           POSTGRES_USER: barae
           POSTGRES_PASSWORD: testpassword
           POSTGRES_DB: barae_test
           SERVER_HOST: 0.0.0.0
           SERVER_PORT: 3000
           APP_SECRET: test-secret-for-ci-at-least-32-characters-long
           SMTP_HOST: mailpit
           SMTP_PORT: 1025
           SMTP_SECURE: "false"
           EMAIL_FROM: "Barae <noreply@barae.local>"
         ports:
           - "3000:3000"
         healthcheck:
           test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
           interval: 5s
           timeout: 3s
           retries: 30
           start_period: 10s
     ```
     Key changes from existing:
     - Build context is `.` with `Dockerfile.backend`
     - Removed FRONTEND_URL and MIGRATE_ON_START
     - Mailpit ports not exposed (tests use internal network)
     - No proxy service needed for tests (backend accessed directly)

  5. Update `.env.example` at project root:
     Clean up the env example to reflect the new architecture:
     - Remove VITE_API_URL (frontend doesn't use env vars)
     - Remove FRONTEND_URL (not used in current config)
     - Remove HTTP_PORT (Caddy handles ports)
     - Add DOMAIN for production Caddy config
     - Remove GitHub vars for now (Phase 4)
     - Keep database, server, security, and SMTP sections
     - Add comments explaining Caddy handles frontend routing

  6. Update `.gitignore`:
     - Add `caddy/data/` and `caddy/config/` in case Caddy local dirs are used
     - Keep existing entries

  7. Delete old files that are no longer needed:
     - Delete `backend/Dockerfile` (replaced by root Dockerfile.backend)
     - Delete `backend/.dockerignore` (build context is now project root)
     - Delete `frontend/Dockerfile` (replaced by root Dockerfile.proxy)
     - Delete `frontend/.dockerignore` (build context is now project root)
     - Delete `frontend/nginx.conf` (replaced by Caddy)

  8. Create a `.dockerignore` at project root (since build context is now the root):
     ```
     .git
     .gitignore
     .planning
     .claude
     .agents
     .env
     node_modules
     **/node_modules
     **/dist
     **/.git
     **/npm-debug.log
     README.md
     LICENSE
     ```
  </action>
  <verify>
  - `cat Dockerfile.backend` -- shows multi-stage with COPY backend/ prefix, copies migrations + scripts
  - `cat compose.dev.yml` -- shows 5 services (db, mailpit, backend, frontend, proxy), context: ., port 8100
  - `cat compose.prod.yml` -- shows 3 services (db, backend, proxy), caddy-data volume, DOMAIN env
  - `cat compose.test.yml` -- shows context: . with Dockerfile.backend
  - `test ! -f backend/Dockerfile` -- old Dockerfile deleted
  - `test ! -f frontend/Dockerfile` -- old Dockerfile deleted
  - `test ! -f frontend/nginx.conf` -- nginx config deleted
  - `cat .env.example` -- no VITE_API_URL, no FRONTEND_URL, has DOMAIN
  - `cat .dockerignore` -- root-level dockerignore exists
  </verify>
  <done>Root-level Dockerfiles created, all 3 compose files rewritten for Caddy architecture, old nginx/Dockerfiles removed, .env.example updated, .dockerignore at root.</done>
</task>

</tasks>

<verification>
1. `ls caddy/Caddyfile.dev caddy/Caddyfile.prod` -- Caddy configs exist
2. `ls Dockerfile.backend Dockerfile.proxy` -- root Dockerfiles exist
3. `test ! -f backend/Dockerfile && test ! -f frontend/Dockerfile && test ! -f frontend/nginx.conf` -- old files removed
4. `grep "8100" compose.dev.yml` -- dev accessible on port 8100
5. `grep "barae-dev-proxy" compose.dev.yml` -- proxy service with correct name
6. `grep "handle_path /api/\*" caddy/Caddyfile.dev` -- API stripping configured
7. `grep "DOMAIN" compose.prod.yml` -- domain env var used in prod
8. `grep "Dockerfile.backend" compose.dev.yml` -- correct Dockerfile reference
</verification>

<success_criteria>
- Dev compose defines 5 services: db, mailpit, backend, frontend (Vite), proxy (Caddy) -- all accessible through port 8100
- Prod compose defines 3 services: db, backend, proxy (Caddy with static files) -- ports 80/443
- Test compose defines 3 services: db, mailpit, backend -- direct backend access on port 3000
- Caddy dev config: HTTP-only, strips /api/ prefix, proxies to Vite and backend
- Caddy prod config: auto-HTTPS, security headers, static files with SPA fallback, strips /api/
- All Dockerfiles at project root with backend/ and frontend/ prefixed COPY paths
- Old nginx.conf and subdirectory Dockerfiles deleted
- .env.example reflects new architecture (no frontend env vars, has DOMAIN)
</success_criteria>

<output>
After completion, create `.planning/phases/01-dev-environment-infrastructure/01-03-SUMMARY.md`
</output>
